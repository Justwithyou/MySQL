# MySQL 

MySQL 最与众不同的特性：**存储引擎架构**，这种架构设计将查询处理及其他系统任务和数据的存储/提取相分离；

## 1 MySQL 架构和历史

### 1.1 MySQL 逻辑架构

MySQL 的逻辑架构：客户端（链接处理、安全认证）、核心部分（包括查询分析、解析、优化、缓存、内置函数和所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图）、存储引擎（MySQL 中数据的存储和提取）

#### 1.1.1 连接管理与安全性

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流的在某个 CPU 核心或者 CPU 中运行；服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程（MySQL 5.5 或者更新的版本提供了一个API，支持线程池，可以使用池中少量线程处理大量的连接）；

#### 1.1.2 优化与执行

MySQL 会解析查询，并创建内部数据结构（解析树），然后对其各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等；

存储引擎对优化查询是由影响的；优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等；

对 SELECT 语句，在解析查询之前，服务器会先检查查询缓存，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行整个过程，而是直接返回查询缓存中的结果集；

### 1.2 并发控制

MySQL 两个层面的并发控制：服务器层和存储引擎层

#### 1.2.1 读写锁

两种类型的锁：共享锁（读锁）和排他锁（写锁）

读锁：共享的，相互不阻塞的，多个客户端可以同时读取同一个资源，且互不干扰；

写锁：排他的，一个写锁会阻塞其他的写锁和读锁；

#### 1.2.2 锁粒度

一种提高共享资源并发性的方式就是让锁定对象更具选择性，尽量只锁定需要操作的部分数据而不是所有的资源；更理想的方式是，只会对修改的数据片进行精确的锁定；任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不冲突即可；

同时加锁也需要消耗资源，锁的各种操作，包括获得锁、检查锁是否已解除、释放锁等，都会增加系统的开销；如果系统花费大量时间管理锁，而不是操作数据，则系统的性能可能因此受到影响；

所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡；

**表锁**

MySQL 中最基本的锁策略，并且是开销最小的锁策略；

表锁会锁定整张表，一个用户在对表进行写操作（插入、删除、更新）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作；

**行级锁**

行级锁可以最大程度的支持并发处理，同时也带来最大的锁开销；在 InnoDB 和 XtraDB 以及其他一些存储引擎中实现了行级锁；行级锁只在存储引擎层实现；

### 1.3 事务

事务：一组原子性的 SQL 语句，或者一个独立的工作单元；事务内的语句，要么全部执行成功，要么全部执行失败；

事务：START TRANSACTION ······ COMMIT

ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

#### 1.3.1 隔离级别


#### 1.3.2 死锁


#### 1.3.3 事务日志 